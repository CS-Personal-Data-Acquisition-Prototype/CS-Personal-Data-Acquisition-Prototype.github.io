{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the homepage for the Personal Data Acquisition Prototype Team!</p> <p>Here, you'll find everything there is to know about our team, including: our documentation, design specifications, and code repositories.</p> <p>Navigation can be found on the left side of the screen.</p> <p>Start with the Project Overview.</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":""},{"location":"acknowledgements/#project-partner","title":"Project Partner","text":"<p>Chris Patton</p> <p>Patton Dynamics LLC</p>"},{"location":"acknowledgements/#capstone-cs-team","title":"Capstone CS Team","text":""},{"location":"acknowledgements/#bradley-tyler","title":"Bradley Tyler","text":"<p>tylerbra@oregonstate.edu</p>"},{"location":"acknowledgements/#colby-noah","title":"Colby Noah","text":"<p>noahc@oregonstate.edu</p>"},{"location":"acknowledgements/#elizabeth-young","title":"Elizabeth Young","text":"<p>younge5@oregonstate.edu</p>"},{"location":"acknowledgements/#garrett-mcmichael","title":"Garrett McMichael","text":"<p>mcmichag@oregonstate.edu</p>"},{"location":"acknowledgements/#joey-abruzzo","title":"Joey Abruzzo","text":"<p>abruzzoj@oregonstate.edu</p>"},{"location":"acknowledgements/#max-goldstein","title":"Max Goldstein","text":"<p>goldstem@oregonstate.edu</p>"},{"location":"acknowledgements/#morgan-padberg","title":"Morgan Padberg","text":"<p>padbergm@oregonstate.edu</p>"},{"location":"design/","title":"Design Document","text":""},{"location":"design/#design-document-capstone-2025-cs026-personal-data-acquisition","title":"Design Document Capstone 2025 CS.026 Personal Data Acquisition","text":""},{"location":"design/#1-overview","title":"1. Overview","text":""},{"location":"design/#11-introduction","title":"1.1 Introduction","text":"<p>In the field of data acquisition, there exists a significant gap between high-cost professional solutions and low-budget DIY alternatives. Our project aims to bridge this gap by developing an easy-to-use, low-cost, modular system designed to accommodate a diverse range of needs. This document provides an in-depth overview of the architectural decisions we\u2019ve made to help guide our system development. By prioritizing affordability, flexibility, and modularity, we will offer a solution that lowers the barriers into the data acquisition field.</p>"},{"location":"design/#12-goals-and-principles","title":"1.2 Goals and Principles","text":"<p>As reflected in the requirements document, the key architectural goals are accessibility, flexibility, modularity, ease of use, security, and performance. We want our system to be low cost, easy to set up, and provide easy to understand data. It should be usable for someone without deep technical knowledge or with limited time to learn a new system. Along with the goal of a lightweight, easy to pick up system, we want it to perform well without the user needing to spend time testing and configuring the hardware and software.</p>"},{"location":"design/#13-technologies-frameworks-and-patterns","title":"1.3 Technologies, Frameworks, and Patterns","text":"<p>At a broad level we will be using an n-tiered architecture pattern to emphasize separation of concerns while improving scalability, reusability, modularity, and encapsulation. The n-tier architecture splits the software into multiple distinct layers that provide a logical division of functions, the typical n-tiered system splits the project into three layers: UI, Business Logic (BLL), and Data Access (DAL). The n-tiered pattern dependency flows down, which means the UI depends on the BLL, which in turn depends on the DAL. The resulting downside of the n-tiered pattern is the BLL requires a valid DAL to compile and run which increases development and testing complexity.</p> <p>Using a Microservice architecture could address some of these issues by decomposing the application into small, independent services that can be developed, deployed, and scaled independently. However, microservices introduce significant overhead in terms of infrastructure management, requiring tools like Kubernetes for orchestration. For our project, which does not require the extreme scalability or distributed processing that microservices provide, the added complexity would outweigh the benefits. As a scalability solution, our BLL and DAL will be hosted through AWS which will allow both resources to easily be scaled and deployed in different geographic regions as the project needs change. As for the rest of the project, the UI is simply hosted on the user's device and the hardware is user specific without the need to scale.</p> <p>To remove the layer interdependency without committing to microservices, we can focus on the clean (also known as hexagonal, ports-and-adapters, and onion) architecture pattern along with dependency injection as the main driving focus which focuses on decoupling the BLL and DAL systems. Using the clean architecture as well as asynchronous messaging, as the main systems involve networking and web interaction, the tiers can be decoupled entirely which will also allow an increase in development flexibility as each layer can be developed and tested independently. In the clean architecture pattern, the decoupling between the layers is achieved by deferring communication to abstracted functions that each representative layer implements.</p> <p>Figure 1 below contains an overview of our project's clean architecture design which will be decoupled into five different system categories; frontend, backend, hardware, database, and external APIs. The core of the diagram, the backend, has no dependencies on any other parts but communicates through an abstracted interface. The middle layer consists of the frontend, database, and hardware components, each of which communicates with the backend through the abstracted functions or external APIs but never directly within the layer. Finally, the external APIs rely on functionality created by the middle layer and are therefore dependent on it. The complete backend decoupling along with the abstracted interfaces allows each component and layer to be developed independently of each other.</p> Figure 1: Architecture Design Diagram"},{"location":"design/#131-ui-layer-frontend","title":"1.3.1 UI Layer - Frontend","text":"<p>The primary UI layer will be a Rust based web app running on the users' device, utilizing egui along with the plot extension for graphing functionality to render a custom interface in a pure Rust environment. Egui offers OpenGL integration for 3D and general shader access through either glow or wgpu allowing low-level access to WebGL2 or WebGPU. The UI layer will communicate with the BLL through an abstracted TCP API which sends requests following a client-server pattern.</p>"},{"location":"design/#132-business-logic-layer-backend","title":"1.3.2 Business Logic Layer - Backend","text":"<p>The primary BL layer will be a Rust based TCP server which implements the abstracted TCP API the UI layer will interface with. The BLL will request data, parse it according to its business rules, and then return the result to the UI layer. It acts as a \u2018black box\u2019 of application logic where the UI requests are decoded to make the relevant DAL requests through a separate, abstracted DAL API. The TCP API will follow a RESTful API format and is expanded upon in the Data Architecture section.</p>"},{"location":"design/#133-data-access-layer-database","title":"1.3.3 Data Access Layer - Database","text":"<p>The DA layer will implement the abstracted DAL API to facilitate communication between a respective database and the BLL. The primary DAL will implement communication for an AWS relational database utilizing Amazon RDS. The DAL API will follow a RESTful API format and is expanded upon in the Data Architecture section.</p>"},{"location":"design/#134-hardware","title":"1.3.4 Hardware","text":"<p>Hardware implementation for this project will consist of six sensors, being created by the ECE Capstone team, as well as a data transfer module built by the CS Capstone team that consists of a single board computer to extract the data from the sensors and transfer the data wirelessly via Wi-Fi or cellular technologies. The Hardware will also implement communication with a local SQLite3 database utilizing the rustqlite crate to allow data to be stored when missing a network connection.</p> <p>The ECE's decision making originally caused us to work with some unknowns and create our own hardware design portion of the project, which simplified the overall communication of our projects in the end. We collaborated and established a protocol that will lead to simple integration of our two team's portions of the project. Recently their communication process has allowed us to hone in on some of the more minute details of the integration process.</p>"},{"location":"design/#2-core-components","title":"2. Core Components","text":""},{"location":"design/#21-user-interface","title":"2.1 User Interface","text":"<p>The user interface will start on a Login page with text inputs for a username and password. Once logged-in, the Home page will be displayed with sections that can be clicked on to view in more detail. Sections will include: a session history window, a device connection window, and an account information window. Here, the user will be able to select a session dataset to view graphs and other information, or export the data to a document for download. Historical session datasets will be visibly sorted by a variety of options such as by date and duration. Throughout the UI, the device connection section will display date, time, and other information. </p> <p>Once an old session is selected or a new session is created, the Sensor Readout page will be displayed. The Readout page will include: configuration windows, a session control window, the device connection window, and the sensor data display window. The historical or live data will be shown here, as well as important status information such as latency, uptime, and which sensors are operating. When multiple sensors are operating and transmitting data at once, there will be multiple panels showing visualized data relevant to each. If those sensors are offline, the panels will be grayed out with a message telling the user of the status (errors, disabled in settings, etc). Data will be displayed through relevant graphs or maps, and the user will be able to select the format they prefer.</p> <p>As the device and web app are operating, errors will be displayed as pop-ups with relevant information and a button to dismiss. Throughout the app, colors will be persistent and dictated by the selected options in settings. The UI will make use of clearly understandable icons to prevent text overcrowding, as well as simple animations for interaction and transitions between pages. The UI will also adapt to different aspect ratios and screen sizes.</p>"},{"location":"design/#211-configuration","title":"2.1.1 Configuration","text":"<p>In order to keep things as accessible as possible, the user will be able to configure the device through the UI on the web app. Sections to include will be sensor calibration and testing, data filtering and visualization settings, and UI settings such as theme, colorblind modes, and light/dark mode.</p>"},{"location":"design/#212-low-fidelity-design","title":"2.1.2 Low-Fidelity Design","text":"Figure 2: Login Page Excalidraw Design Figure 3: Home Page Excalidraw Design Figure 4: Sensor Readout (Single) Page Excalidraw Design Figure 5: Sensor Readout (Multi) Page Excalidraw Design"},{"location":"design/#213-high-fidelity-design","title":"2.1.3 High-Fidelity Design","text":"Figure 6: Login Page Figma Design Figure 7: Home Page Figma Design Figure 8: Sensor Readout (Table) Page Figma Design Figure 9: Sensor Readout (Multi) Page Figma Design Figure 10: Sensor Readout (Map) Page Figma Design"},{"location":"design/#22-authentication-and-security","title":"2.2 Authentication and Security","text":"<p>Communication and data transfer, real-time or otherwise, will be secured using a system modeled after Transport Layer Security (TLS) using Diffie-Hellman (DH) for traffic encryption key (TEK) exchange, digital signatures for authentication, HMAC for integrity, AES-128-CBC for encryption, along with periodic key checks to ensure security. AES-256-CBC could also be used for increased security at the cost of performance, but AES-128-CBC was chosen due to the performance increase and the security level of our use case. Security during user authentication could further be increased through the use of multifactor authentication (MFA) or one time passwords (OTP) to reduce the frequency of sensitive data transfer.</p> <p>The user password will be processed using Argon2id to ensure data security. All user secrets the software doesn\u2019t need to know will be transferred, stored, and processed as the SHA-256 hash of the user secret to protect against user secret leaks due to data breaches. Security could be increased as needed in the future using salting and additional hash functions. Any user secrets the software requires access to will be stored encrypted with AES-256-CBC using a randomly generated 256-bit data access key (DAK). The DAK will also be stored encrypted with AES-256-CBC with a 256-bit key encryption key (KEK) which will be stored in a secure external key management system such as AWS or Google Cloud key management service.</p> <p>Simple password rules such as an eight character minimum, no passwords matching a username, and number/symbol requirements will be enforced to help users choose a secure password. To further help users ensure security, a bloom filter could be added at a later date to ensure users don\u2019t pick common or compromised passwords.</p>"},{"location":"design/#23-hardware","title":"2.3 Hardware","text":"<p>The Data logger is being designed using a Raspberry Pi as the central controller and data collector. Based on this design plan, we are using a Raspberry Pi with a 4G LTE module to implement increased data transfer speed and distance capability. By using a Raspberry Pi 5, we will have the capability to transfer data via USB to USB, Bluetooth, Wi-Fi. With the addition of a 4G LTE module, our system will be able to provide real-time data anywhere there is cellular service. We will be implementing a Bluetooth or USB to USB connection from the hardware sensors the ECE team is developing to the Data logger. Additionally, we will be able to have a built-in display for battery status and cellular connection.</p> <p>Other design considerations we have accounted for with this hardware is that we will use a battery power pack for the power supply. We also will create a water-resistant case that allows for USB connections to the Raspberry Pi and the antenna for the cellular data. </p>"},{"location":"design/#3-data-architecture","title":"3. Data Architecture","text":""},{"location":"design/#31-abstracted-apis","title":"3.1 Abstracted APIs","text":"<p>Moved to API specification document.</p>"},{"location":"design/#32-er-diagram","title":"3.2 ER Diagram","text":"Figure 11: Entity Relationship Diagram"},{"location":"design/#33-data-flow-diagram","title":"3.3 Data Flow Diagram","text":"Figure 12: Data Flow Diagram"},{"location":"design/#4-testing-strategies","title":"4. Testing Strategies","text":"<p>Our methods for testing the integrity of both the device and our software handling the data, user-interface, and other elements will consist of a mix of automated and manual testing. We have access to simulation data, which can be used in the automated tests to ensure that data is being handled correctly from the database to the application.</p> <p>Automated testing can validate our backend functionality such as the data logging on the device, data conversion &amp; transmission to the server, and database storage &amp; retrieval. Implementing unit tests will be the easiest route for the more independent cases like logging &amp; data conversion. Integration tests can be used for the parts that involve multiple components of the system, like data transmission and retrieval. Additionally, we will implement a suite of tests with the goal of tracking the performance of the software and comparing it to an ideal range. The latency of data transmission needs to be tracked, and the amount of time it takes to process and display data should be tracked as well. Rust has a built-in testing command (cargo test) that can be used to run all of these tests.</p> <p>Manual tests will be needed for user-interface (UI) and user-experience (UX) testing, which would involve gathering real test users who will use the application with simulation data. The goal of these tests is to ensure that the UI is responsive and provides useful information without confusing the user. After the user has completed the pre-defined tasks, there will be a survey for them to complete. This allows us to collect feedback and metrics on which parts of the application need improvement and if the overall design meets the user\u2019s needs.</p> <p>When the physical device enters the prototyping stage, manual tests with real world data will need to be performed involving the entire system. Ideally, these tests would be performed in the same situations where the data logger will be used, such as a Global Formula Racing kart at OSU. Data from each sensor should be collected and verified to make certain that the device will work in real world conditions.</p>"},{"location":"design/#5-considerations","title":"5. Considerations","text":"<p>This section outlines items we have considered for optimizing system performance, planning for maintenance, and ensuring long-term support. To enhance performance, potential bottlenecks such as data transmission rates, memory usage, database queries, and graphics rendering will be analyzed. Tools will be developed to monitor hardware usage, latency, and other metrics, with an optional dev mode for easier troubleshooting. Stress testing and iterative optimization will ensure the system meets listed performance goals. Maintenance practices will be established during development and continued post-deployment while scalability options will be explored to enhance future capabilities.</p>"},{"location":"design/#51-optimizing-system-performance","title":"5.1 Optimizing System Performance","text":"<p>To optimize performance, both for our device and application, we will first need to analyze bottlenecks. Expected bottlenecks include:</p> <ul> <li>Data transmission rates and latency   </li> <li>Memory and local storage usage  </li> <li>Database queries  </li> <li>Data filtering/analysis algorithms  </li> <li>Graphics rendering</li> </ul> <p>In order to measure the impact these aspects might have, we will develop tools to monitor hardware usage, performance, latency, and other metrics that will be important to know. Some of these metrics will be visible to the user, but an optional dev mode will be used to make things easier to see. This will also provide a benefit to the end user so they can troubleshoot on their own. Once we know where our bottlenecks are, we can compare performance to our expected values, and optimize our code to improve it. Some reasonable performance goals include:</p> <ul> <li>500ms or less response time for user interaction and navigation in the web app  </li> <li>2-3 second of latency for \u201creal-time\u201d data transmission, and frequent refreshing to prevent delays between data receiving and display  </li> <li>Fast graphics loading, no more than a few seconds</li> </ul> <p>During development we will continually test to make sure that performance is within a reasonable distance of our goals to prevent being locked in to a method that performs poorly but is a core and difficult to change aspect of our system. We will conduct stress testing on our systems to determine aspects like data transmission sizes, refresh rates, and so on. Here are some choices we have made that will help improve the performance of our systems:</p> <ul> <li>Keep minimal data stored on the recording device to save storage and memory. It should be uploaded to a remote database and then cleared from memory  </li> <li>Compare algorithms for data filtering and analysis to determine best performance  </li> <li>Optimize database queries, as they can be a major slowdown  </li> <li>Optimize graphics in the UI, as it can be a major use of system resources, and test on devices with different graphics hardware to ensure performance stays consistent</li> </ul>"},{"location":"design/#52-planning-for-maintenance-and-long-term-support","title":"5.2 Planning for Maintenance and Long-Term Support","text":""},{"location":"design/#521-maintenance","title":"5.2.1 Maintenance","text":"<p>During development, we will get into the habit of performing several maintenance tasks that will continue after deployment. We will create periodic and well-organized backups of our codebase, previous versions, testing methods, and data. User data will be stored separately and securely, following the security procedures outlined in this document. During development, a latest stable build will be kept available, and a test build will be worked on. This will continue post-deployment. There should always be a functional and tested build available. A team of willing group members will monitor bugs and perform bug fixes after deployment during the lifespan of our project.</p>"},{"location":"design/#522-scalability","title":"5.2.2 Scalability","text":"<p>After successful deployment of our project, we can expand upon it with newer features that will enhance its capabilities. A proper user account system allowing for cloud storage of data and monitoring on multiple devices is something we would consider pursuing. Another option would be to build a modular system for sensors, allowing the user to customize their device and upgrade it later. </p>"},{"location":"design/#523-user-support-and-documentation","title":"5.2.3 User Support and Documentation","text":"<p>It\u2019s too early in our project to determine exact specifics of our user support system. As we come closer to deployment these details will be ironed out. Currently we envision user support being provided through a simple ticket system with communication through email. User suggestions can also be taken this way. These systems will be handled through our project website. For documentation, we will write a comprehensive documentation article that will be hosted on our website. It will include an overview of features, a UI guide, tutorials and examples, and FAQs. It will make good use of images to aid users and will be divided into chapters for easy navigation.</p>"},{"location":"design/#6-programming-style-guide","title":"6. Programming Style Guide","text":"<p>Group members should adhere to the following guidelines to ensure that the code is simple, clear, and consistent regardless of the author.</p>"},{"location":"design/#61-naming-conventions","title":"6.1 Naming Conventions","text":"<p>Names should be straightforward and descriptive. Generally, avoid abbreviations and single-letter names unless they are self-explanatory. In the case of ambiguous naming that is unavoidable, add a comment explaining the name. For variables and classes, use nouns or noun phrases, and for functions and methods, use verbs. Lastly, names should be easily pronounceable in English to make it easier to collaborate.</p> <p>The following table summarizes the preferred typographical conventions for languages used in the project:</p> Constants Variables Types Functions Modules Rust UPPER_CASE snake_case UpperCamelCase snake_case snake_case Python UPPER_CASE snake_case UpperCamelCase snake_case lowercase Table 1: Project Naming Conventions"},{"location":"design/#62-spacing-and-indentation","title":"6.2 Spacing and Indentation","text":"<p>Include spaces on either side of infix operators (e.g., \\=, +, -, *, /, etc.). An exception to this rule is the use of colons (:) and double colons (::) for slicing in Python and as a path separator in Rust.</p> <p>Always place a space after a comma and never before. Spaces should precede parentheses, except for in function calls. Open curly braces and colons used to indicate new blocks of code should never be on their own line and should always be followed by a new line.</p> <p>Separate items and statements with either one or two newlines. Use whitespace at logical breakpoints to increase readability of the code. Use four spaces for indentation. Never mix spaces and tabs.</p> <p>The following example demonstrates preferred spacing and indentation for functions, function calls, and expressions in Rust:</p> Figure 13: Rust Formatting Preference Example"},{"location":"design/#63-comments","title":"6.3 Comments","text":"<p>Use comments to add context or explain choices that are not already understandable through thoughtful naming or structure. Comments should be meaningful; do not use them for self-explanatory code (e.g., // Increment x by 1). When working on code, make use of detailed TODO comments to help direct yourself and your collaborators, keep track of issues, and record ideas. Lastly, remember that comments require maintenance. As such, always edit the corresponding comments when modifying code and avoid leaving redundant comments.</p>"},{"location":"design/#64-html","title":"6.4 HTML","text":"<p>The first line should declare the document type. Always include the \\&lt;title&gt;, \\&lt;html&gt;, \\&lt;meta&gt;, \\&lt;head&gt;, and \\&lt;body&gt; tags. Specifically, make the \\&lt;title&gt; element as accurate as possible, and specify \\&lt;html lang=\u201den-us\u201d&gt; and \\&lt;meta charset=\u201dutf-8\u201d&gt; to declare the language of the webpage and ensure correct encoding.</p> <p>Always close non empty HTML elements and add blank lines to increase readability, especially when creating nested elements such as tables or lists. The following image demonstrates how to create a table with proper spacing:</p> Figure 14: HTML Table Formatting Preference Example"},{"location":"design/#65-rustfmt","title":"6.5 rustfmt","text":"<p>Given that Rust is the primary programming language for the project, it is especially important that group members follow the same guidelines when coding in Rust. This is easily accomplished by using rustfmt, a tool that formats Rust according to the standardized style guidelines. These guidelines include the spacing and indentation rules outlined above.</p> <p>The rustfmt tool is automatically downloaded when a user installs Rust and can be applied to the current working directory by running cargo fmt on the Stable toolchain or cargo +nightly fmt on the Nightly toolchain. Alternatively, it is recommended that all group members that use Visual Studio Code install the rust-analyzer extension. Editing the settings.json file for Visual Studio Code to include the following lines will ensure that the rustfmt tool is applied whenever a file is saved:</p> Figure 15: Adding \u2018rustfmt\u2019 for Consistent Formatting"},{"location":"overview/","title":"Overview","text":"<p>An Affordable data acquisition system with cellular connectivity, providing low-latency personal performance data, in the palm of your hand.</p> <p>Our CompSci Capstone team is partnering with an ECE team to develop a complete sensor data acquisition device. With the ECE team's hardware sensors providing us data, we're sending data with an LTE-capable platform to an online backend. This is all accessible from our online, web-based client.</p>"},{"location":"overview/#project-core","title":"Project Core","text":""},{"location":"overview/#the-problem","title":"The Problem","text":"<ul> <li>Current solutions are expensive, at $5,000+.</li> <li>There are often many individual parts.</li> <li>Too the average layman, interfaces are too complex.</li> <li>A steep learning curve is often required to use current solutions effectively.</li> </ul>"},{"location":"overview/#target-users","title":"Target Users","text":"<ul> <li>OSU Global Formula Racing Team</li> <li>Small labs, startups, educators, hobbyists</li> <li>Go-Karts, Snowmobiles, Mountain Bikes</li> </ul>"},{"location":"overview/#our-solution","title":"Our Solution","text":"<ul> <li>Bridges the professional-hobbyist gap</li> <li>Cost effective, around $500</li> <li>Single Purchase Product (Pi w/ sensors)</li> <li>User friendly interface for non-experts</li> </ul>"},{"location":"overview/#the-communications-module","title":"The Communications Module","text":"<ul> <li>The Raspberry Pi 5 provides a high-performance Linux environment to run Rust programs similar to a full PC while also allowing an LTE module to be mounted via a HAT.</li> <li>A power delivery circuit allows most off-the-shelf USB-C power sources to provide enough current for the Pi.</li> <li>The data is gathered from a collection of sensors containing GPS, force, string, linear, and 9 degrees of freedom sensor.</li> <li>The sensors record and transmit at 100 hz for high precision which produces 5.8 KB/second with future compression possibilities.</li> <li>With constant 24 hour use the sensors produce about 348 KB/min, 20.9 MB/hour, 501 MB/day, 3.5 GB/week, or 15 GB/month.</li> </ul>"},{"location":"overview/#technical-highlights","title":"Technical Highlights","text":"<ul> <li>Pi receives ECE Team\u2019s data via USB or WIFI</li> <li>Pi transmits data batches to AWS via 4G LTE</li> <li>Pi transmits low-latency data via WebSockets</li> <li>Flexible SQLite DB can allow new sensor types</li> <li>Scaliable TCP server utilizing pattern matching</li> <li>Cross-platform web-based data visualizations</li> <li>All software is written entirely in Rust</li> </ul>"},{"location":"overview/#diagrams","title":"Diagrams","text":""},{"location":"overview/#data-acquisition-system-overview","title":"Data Acquisition System Overview","text":""},{"location":"overview/#database-entity-relationship-diagram","title":"Database Entity Relationship Diagram","text":""},{"location":"overview/#architecture-design-diagram","title":"Architecture Design Diagram","text":""},{"location":"repositories/","title":"Codebase","text":""},{"location":"repositories/#github-organization","title":"Github Organization","text":"<p>Our team's codebase is held by a GitHub organization: CS Personal Data Acquisition Prototype.</p> <p>The organization can be found here.</p>"},{"location":"repositories/#repositories","title":"Repositories","text":"<p>The following are our most important repositories:</p>"},{"location":"repositories/#rust-tcp","title":"Rust-TCP","text":"<ul> <li>AWS-Based Service for the project.</li> <li>Also serves user web client.</li> </ul>"},{"location":"repositories/#pi_tcp","title":"Pi_TCP","text":"<ul> <li>Parses incoming data into SQLite database on the Pi</li> </ul>"},{"location":"repositories/#pi_transmit","title":"Pi_Transmit","text":"<ul> <li>Transmits the local SQLite database to the AWS-based services.</li> </ul>"},{"location":"repositories/#ui-layer","title":"UI-Layer","text":"<ul> <li>User web client frontend</li> </ul>"},{"location":"specification/","title":"Requirements Document","text":""},{"location":"specification/#software-requirements-specification-for-personal-data-acquisition-prototype","title":"Software Requirements Specification for Personal Data Acquisition Prototype","text":""},{"location":"specification/#1-overview","title":"1. Overview","text":""},{"location":"specification/#11-problem-description","title":"1.1 Problem Description","text":"<p>Personal data acquisition systems are systems that gather sport performance data on the way the athlete and the equipment they are using or operating is performing and provides feedback where improvements can be made. Today\u2019s personal data acquisition systems largely fall into two categories. Category one is professional data acquisition systems, which provide the user high quality data to analyze. However, these systems are expensive, difficult to install, create a massive amount of data to transmit and store, and possibly require a high acumen with computer systems if something goes wrong. Category two is more cost-efficient Do It Yourself (DIY) systems. These systems solve the cost issue of professional systems and depending on the number and type of sensors, can reduce the amount of data that is transmitted and processed. The trade-off for the DIY systems is that the level of programming and computer systems expertise required grows exponentially.</p> <p>In between these two categories, there is a void that leaves many people looking to improve their performance by accessing the power of data acquired while performing their sport.</p>"},{"location":"specification/#12-purpose-and-vision","title":"1.2 Purpose and Vision","text":"<p>Our project will fill the void between the professional and DIY data acquisition systems that are available today. We will build a low cost modular data acquisition system that will be simple to install and use. We aim to create an easy-to-use, real time user interface that allows any user to install the system and use the data effortlessly, improving their performance without a significant background in computer systems. Our data acquisition system will have the capability to locally store and live stream the most important data for instant feedback.</p>"},{"location":"specification/#13-users-and-stakeholders","title":"1.3 Users and Stakeholders","text":"<ul> <li>Alex Ulbrich  </li> <li>Kirsten Winters  </li> <li>Chris Patton (Project Partner)  </li> <li>OSU Global Formula Racing club  </li> <li>Feipeng Yue (Winter 2025 TA)  </li> <li>ECE 44X Team  </li> <li>Group Members  <ul> <li>Bradley Tyler  </li> <li>Colby Noah  </li> <li>Garrett McMichael  </li> <li>Joey Abruzzo  </li> <li>Lisa Young  </li> <li>Max Goldstein  </li> <li>Morgan Padberg</li> </ul> </li> </ul> <p>Chris Patton is carrying out the role of project partner. He has stated that he will be able to provide us with previous years\u2019 GitHub repositories, testing data for our prototype, and some amount of contact with the Global Formula Racing club at OSU. He has provided us with a basic framework for how our prototype should function, as well as constraints in the form of a preferred programming language (Rust). Chris Patton and the teaching team for this project (Alex Ulbrich, Kirsten Winters, and Casey) all have a stake in this project due to the time that they are investing in it. For the project partner, this investment may extend to a financial one.</p> <p>We are using the OSU Global Formula Racing club as a proxy for our assumed user base. This means that when we perform user experience surveys, they will be our respondents. It is also possible that they will be able to make actual and significant use of our prototype if we are able to meet their needs.</p> <p>We are working on this project alongside an ECE team. Since our product requires hardware that we will have to purchase, both teams have a financial stake in the outcome of this project. As a stretch goal we are also considering the possibility of turning the final prototype into a purchasable product, which will result in an even greater time and work investment. Moreover, our grades in the class depend partly on the successful implementation of the product.</p>"},{"location":"specification/#2-preliminary-context","title":"2. Preliminary Context","text":""},{"location":"specification/#21-assumptions","title":"2.1 Assumptions","text":"<p>The product we are developing is a prototype personal data logger for amateur F1 cars. The data logger will receive information from six sensors: accelerometer, yaw rate, GPS, force transducer, linear potentiometer, and string potentiometer. It will record data at 100Hz - 5,000Hz and live stream the information to a website on a remote device.</p> <p>We will be using Rust for the majority of the coding, as requested by the project partner, along with choosing either egui or OpenGL, though wgpu, for the graphics.</p>"},{"location":"specification/#22-constraints","title":"2.2 Constraints","text":"<p>We may be limited by the fact that we are primarily using Rust since none of the team members have coded in Rust before. Moreover, previous teams for this project have stated that using Rust and egui for the frontend resulted in a primitive UI, and suggested that Rust and egui be avoided for frontend. This results in a tradeoff: if we use egui, we will have the expertise of our project partner but most likely have a lacking end result. On the other hand, if we use Rust and OpenGL, we may no longer be using a coding language and library that the project partner is familiar with, but could end up with a much more sophisticated UI. However, if that UI is limited in functionality, the project may fall short of these requirements.</p> <p>Our prototype will be transmitting a large amount of data. This means that we will need to perform a significant amount of data compression to properly display the data in a timely and readable manner.</p>"},{"location":"specification/#23-dependencies","title":"2.3 Dependencies","text":"<p>We need a database to hold the data from the data logger, user logins and user settings.</p> <p>We are building off previous years work and will need to adapt to the current data logger being set up by the ECE team.</p> <p>We are building a web application and will need to design a prototype and get feedback from the Oregon State University GFR Team prior to coding the User Interface.</p> <p>Getting realistic test data and access points to the data logger require us to be dependent on other stakeholders.</p>"},{"location":"specification/#24-market-assessment-and-competition","title":"2.4 Market Assessment and Competition","text":"<ul> <li>Oregon State University\u2019s Global Formula Racing team currently uses Vector for data collection  </li> <li>High cost (https://www.ebay.com/itm/324655452701)   </li> <li>Dragy GPS data logger popular with vehicle tuners  <ul> <li>Corresponding mobile app has a rating of 1.1 stars on the App Store, with users reporting that the performance report and other features do not load properly  </li> <li>High cost  <ul> <li>GPS and performance recorder is $229.00  </li> <li>Company promotes accessories that cost up to $39.50  </li> </ul> </li> </ul> </li> <li>JB Data Engineering  <ul> <li>$3350 entry point  </li> <li>High technical knowledge required to install</li> </ul> </li> </ul>"},{"location":"specification/#25-target-demographics","title":"2.5 Target Demographics","text":"<p>The ideal target demographic for this project would be hobbyist or low-level professionals who are less technically proficient or more time constrained. Existing products have a high capability ceiling that can be used by professionals or high-level hobbyists with enough time to dedicate to them, but have a high barrier to entry. Our project will have a lower capability ceiling, but lower barrier to entry since it should take significantly less time to get up and running and produce useful results. Examples include hobbyist and small club-level racers or mountain bikers. These users might be limited by budget or software knowledge, or might have limited time to spend on their sport. They need quick access to important data, but might not need all the advanced features offered by competing products.</p>"},{"location":"specification/#3-system-requirements-specification","title":"3. System Requirements Specification","text":""},{"location":"specification/#31-functional-requirements","title":"3.1 Functional Requirements","text":"<ul> <li>The user should be able to view real-time or historic data from any selection or subselection of sensors connected to the device.  </li> <li>The client should receive information in real-time from the device when a stable connection is available.  </li> <li>When a stable connection is available between the device and server or the device and client, the client should receive real-time data.  </li> <li>If the device loses connection with the database/web server, the user should be able to view all data captured during the disconnection period when the device reconnects.  </li> <li>After a connection interruption, the client should automatically resume real-time data streaming from the device.  </li> <li>The client should be able to manually or automatically synchronize databases with the device.  </li> <li>The user interface should be easy for new users to navigate.  </li> <li>The web interface should be able to handle both mobile and desktop screen sizes.  </li> <li>The user interface should provide multiple color-blindness accessibility modes.</li> </ul>"},{"location":"specification/#32-non-functional-requirements","title":"3.2 Non-Functional Requirements","text":"<ul> <li>The UI should have user selectable light and dark themes.  </li> <li>The software should have encrypted user passwords and usernames both when at rest or being transmitted.  </li> <li>Device should record data at 100Hz - 5000Hz.  </li> <li>The live streaming data should refresh at least every 2-3 seconds.  </li> <li>The device should upload its local data to the remote server frequently to minimize latency.  </li> <li>The device should immediately delete data from local memory once successfully uploaded to conserve RAM and minimize wear to the device\u2019s flash memory.</li> </ul>"},{"location":"specification/#33-data-requirements","title":"3.3 Data Requirements","text":"<ul> <li>Data should be collected from a variety of sensors and may include:  <ul> <li>Accelerometer  </li> <li>Yaw Rate  </li> <li>GPS  </li> <li>Force transducer  </li> <li>Linear potentiometer  </li> <li>String potentiometer  </li> </ul> </li> <li>Data should be stored locally, then transmitted wirelessly and stored in database  </li> <li>Data must be filtered in order to provide accurate information</li> </ul> <p> Figure 1\u2013Database Entity-Relationship Diagram</p>"},{"location":"specification/#34-integration-requirements","title":"3.4 Integration Requirements","text":"<ul> <li>Rust will be used for the embedded software to capture the data and prepare it to be sent to the external database  <ul> <li>Data formatting  </li> <li>Error handling  </li> <li>Local data storage  </li> </ul> </li> <li>A remote database will store the data collected by the tracker and also be used to retrieve the data as it is displayed on the user interface</li> </ul>"},{"location":"specification/#35-user-interaction-and-design","title":"3.5 User Interaction and Design","text":"<ul> <li>The UI should be visually appealing and simple to navigate  </li> <li>To reduce clutter sub-menus and pages can be used, but should be limited to reduce complexity  </li> <li>Accessibility options like light and dark mode and colorblind modes should be available  </li> <li>Graphs should be easily readable and make good use of colors  </li> <li>Icon use should be clear and easy to understand  </li> <li>Icons should be prioritized over text wherever possible  </li> <li>Pages on the website should load in under 2 seconds and provide smooth visual transitions  </li> <li>Interface should always be clear about what is happening, and the user should never be stuck on a blank page or infinite loading icon</li> </ul>"},{"location":"specification/#36-open-questions","title":"3.6 Open Questions","text":"<p>What are the sensors the ECE team is creating measuring? Which sensor is measuring what data?</p> <p>What is the speed at which the hardware will develop data for each sensor used?</p>"},{"location":"specification/#37-out-of-scope","title":"3.7 Out of Scope","text":"<p>We will not be implementing a mobile specific application.</p> <p>We are considering a subscription service as a form of revenue, but this is currently a stretch goal. Doing so would also require more maintenance past the scope of the class.</p>"},{"location":"specification/#4-project-timelines","title":"4. Project Timelines","text":""},{"location":"specification/#41-milestones","title":"4.1 Milestones","text":"Due Date Feature Description Dependencies CS 461 Week 7 Tech Stack Design Determine the technology stack to use and what resources are required to develop this project, so we can note this in our design document and have all resources available by the start of CS 462. CS 461 Week 7 Version-Control Setup Configure a version-control system repository to host project code on GitHub CS 461 Week 7 Low-Fidelity Design Create a flow or wireframe UI design to understand the broad layout of the application CS 461 Week 8 High-Fidelity Design Create a high-fidelity UI design for the frontend of the main web application for the design document, project partner, and demo assignment. Low-Fidelity Design CS 461 Week 8 Tech Stack Resources Ensure all resources determined necessary in Tech Stack Design are requested/ordered. Tech Stack Design CS 461 Week 9 Local Development Create a test database and webapp to ensure proper communication between the webapp and the DBMS. Tech Stack Design CS 461 Week 10 Development Server Configuration Once the requested development server is available to the team, install software required in Tech Stack Design; grant access to team members as needed. Ensure that the webapp is accessible from the Internet. Tech Stack Resources Local Development (partial) CS 462 Week 1 Database Schema Implementation Design and implement the schema for how the sensor data will be stored, both on the local device and on the remote server. CS 462 Week 2 Mock Data Generation Write code to generate data that would emulate a sensor; this is used to test Week 4 code. Database Schema Implementation CS 462 Week 4 Network Protocol Implementation Design the protocol used to transmit sensor data from the local device and the remote server; implement code to connect the local database with the TCP client and to connect the TCP server to the remote database. Mock Data Generation CS 462 Week 6 Remote Recorded Sensor Data Table Write code to make the web UI display a table of recorded (mock) sensor data. Network Protocol Implementation CS 462 Week 6 Sensor Implementation Design the protocol for communicating between the Bluetooth-enabled sensors and the local device. Database Schema Implementation ECE team\u2019s sensor design CS 462 Week 7 Remote Sensor Graph Write code to add a graph of sensor data to the recorded data table page in the UI, and controls to configure the graph display. Remote Recorded Sensor Data Table CS 462 Week 7 Remote Live Sensor Readout Write the code to make the web UI display a live readout of sensor data. Optionally, include a bar graph in addition to the numeric readout. Network Protocol Implementation CS 462 Week 9 Remote Live Sensor Graph Add a dynamically updating graph to the live sensor readout page to show recently collected data of a selection of sensors. Remote Sensor Graph CS 462 Week 10 (and periodically after) Configuration Page Add a page on the web UI to manage the configuration of both the server and the device. As additional features are added, update this page with necessary controls to configure these features. CS 463 Week 2 Data Management Add a mechanism to the UI to export data to a standardized format (CSV, XLS(X), JSON, etc.); add mechanisms to select and delete data. Remote Recorded Sensor Data Table CS 463 Week 4 Out-of-Box Experience Create an \u201cinitial setup\u201d screen where a user can intuitively configure the device, sensors, and server at first run Sensor Implementation Configuration Page CS 463 Week 5\u000b(ongoing until then) Documentation Proofread documentation created throughout the project; create a table of contents or other method of searching documentation. Completion of software CS 463 Week 6 (due 2025-05-13 12:00) Engineering Expo Poster Create a poster showcasing the project\u2019s features and design to present at the Engineering Expo. CS 463 Week 6 User Testing Complete final user experience surveys to gather any achievable goals within remaining time. Completion of software If time permits Stretch Goals <p>Table 1\u2013Weekly Project Milestones</p>"},{"location":"specification/#_1","title":"Requirements Document","text":""},{"location":"specification/#42-goals-and-success-metrics","title":"4.2 Goals and Success Metrics","text":"Goal Metric Baseline Target Tracking Method Increase usability of product among people with low technical expertise Percentage of survey participants that found the software easy to use 75% 90% Usability study with OSU F1 team Desired features, or equivalent alternatives, are present (compared to previous iterations) Percentage of features included 75% 90% Compare prototype features with desired features found in previous studies Desired features, or equivalent alternatives, are present (compared to currently used product) Percentage of features included 70% 80% Compare prototype features with current OSU F1 software (Vector) <p>Table 2\u2013Identifiable Project Goals and Tracking Metrics</p>"}]}